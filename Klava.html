<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Klavarog Δ</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/stackoverflow-dark.min.css">
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Segoe UI', Tahoma, sans-serif;
      font-size: 13px;
      background: #0d1117;
      color: #c9d1d9;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    #app {
      width: 90vw;
      max-width: 1600px;
      height: 88vh;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    #header {
      display: flex;
      align-items: center;
      gap: 16px;
      padding: 0 4px;
      font-size: 14px;
    }

    #header a {
      color: #58a6ff;
      text-decoration: none;
      cursor: pointer;
      transition: color 0.2s;
      font-weight: 500;
    }

    #header a:hover {
      color: #79c0ff;
    }

    #stats {
      margin-left: auto;
      display: flex;
      gap: 20px;
      font-variant-numeric: tabular-nums;
      color: #8b949e;
    }

    #main-layout {
      flex: 1;
      display: flex;
      gap: 16px;
      min-height: 0;
    }

    #left-panel,
    #right-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 12px;
      background: #161b22;
      padding: 16px;
      border-radius: 8px;
      min-height: 0;
    }

    #text-container {
      flex: 1;
      display: flex;
      flex-direction: column;
    }

    #text {
      flex: 1;
      padding: 16px 18px;
      background: #0d1117;
      font-family: 'Consolas', monospace;
      font-size: 16px;
      line-height: 1.9;
      overflow-y: auto;
      border-radius: 6px;
      word-break: break-all;
      position: relative;
      outline: none;
      cursor: text;
    }

    #text:focus {
      box-shadow: 0 0 0 2px #58a6ff;
    }

    #text .line {
      min-height: 1.9em;
      position: relative;
    }

    #text .char {
      position: relative;
      display: inline-block;
      white-space: pre;
    }

    #text .char.checked {
      color: #7ee787;
    }

    #text .char.current {
      border-bottom: 2px solid #58a6ff;
      animation: blink 1s step-end infinite;
    }

    #text .char.current.error {
      background: #ff7b72;
      color: #fff;
      border-bottom: 2px solid #ff7b72;
    }

    @keyframes blink {
      0%, 49% { border-bottom-color: #58a6ff; }
      50%, 100% { border-bottom-color: transparent; }
    }

    #text .char.current.error {
      animation: none;
    }
    }

    #text .hljs {
      background: transparent;
      padding: 0;
    }

    #explanation-panel {
      flex: 1;
      background: #0d1117;
      padding: 16px 18px;
      border-radius: 6px;
      overflow-y: auto;
      display: block;
    }

    .panel-title {
      font-size: 13px;
      color: #58a6ff;
      margin-bottom: 12px;
      font-weight: 600;
      letter-spacing: 0.5px;
    }

    #explanation-content {
      color: #c9d1d9;
      line-height: 1.6;
      font-size: 13px;
    }

    .word-item {
      margin-bottom: 12px;
      padding: 10px;
      background: #161b22;
      border-left: 2px solid #58a6ff;
      border-radius: 0 4px 4px 0;
    }

    .word-title {
      color: #7ee787;
      font-family: 'Consolas', monospace;
      font-weight: 500;
      margin-bottom: 4px;
      font-size: 14px;
    }

    .word-description {
      color: #c9d1d9;
      font-size: 13px;
    }

    .loading,
    .no-explanations {
      color: #6e7681;
      font-style: italic;
      padding: 12px 0;
    }

    .modal {
      position: fixed;
      background: #161b22;
      border-radius: 8px;
      padding: 24px;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      max-width: 600px;
      width: 90vw;
      z-index: 1000;
      box-shadow: 0 16px 32px rgba(0, 0, 0, 0.5);
      display: none;
    }

    .modal.show {
      display: block;
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      margin-bottom: 16px;
      align-items: center;
    }

    .close {
      cursor: pointer;
      color: #8b949e;
      font-size: 22px;
      font-weight: bold;
      transition: color 0.2s;
    }

    .close:hover {
      color: #c9d1d9;
    }

    button {
      background: #238636;
      color: #ffffff;
      border: none;
      padding: 8px 20px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      transition: background 0.2s;
    }

    button:hover {
      background: #2ea043;
    }

    #dict_data {
      width: 100%;
      height: 260px;
      background: #0d1117;
      color: #c9d1d9;
      border: none;
      border-radius: 6px;
      padding: 12px;
      font-family: 'Consolas', monospace;
      font-size: 13px;
      resize: vertical;
    }

    #dict_data:focus {
      outline: none;
      box-shadow: 0 0 0 2px #58a6ff;
    }

    .modal-options {
      margin-top: 16px;
      padding-top: 16px;
      border-top: 1px solid #30363d;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .modal-options label {
      display: flex;
      align-items: center;
      gap: 10px;
      color: #c9d1d9;
      font-size: 13px;
    }

    .modal-options select,
    .modal-options input[type="text"],
    .modal-options input[type="file"] {
      background: #0d1117;
      color: #c9d1d9;
      border: none;
      border-radius: 6px;
      padding: 6px 10px;
      font-size: 13px;
      flex: 1;
    }

    .modal-options select:focus,
    .modal-options input[type="text"]:focus {
      outline: none;
      box-shadow: 0 0 0 2px #58a6ff;
    }

    .modal-options input[type="file"]::file-selector-button {
      background: #238636;
      color: white;
      border: none;
      padding: 6px 12px;
      margin-right: 10px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
    }

    input[type="checkbox"] {
      width: 16px;
      height: 16px;
      cursor: pointer;
      accent-color: #58a6ff;
    }

    ::-webkit-scrollbar {
      width: 8px;
    }

    ::-webkit-scrollbar-track {
      background: transparent;
    }

    ::-webkit-scrollbar-thumb {
      background: #30363d;
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: #484f58;
    }

    .status-message {
      color: #7ee787;
      font-size: 12px;
      margin-top: 6px;
    }

    .error-message {
      color: #ff7b72;
      font-size: 12px;
      margin-top: 6px;
    }
  </style>
</head>

<body>
  <div id="app">
    <div id="header">
      <a id="dict-link">Текст</a>
      <a id="refresh" title="Обновить">⟳</a>
      <div id="stats">
        <span id="speed" title="Скорость">--</span>
        <span id="error" title="Ошибки">--</span>
      </div>
    </div>

    <div id="main-layout">
      <div id="left-panel">
        <div id="text-container">
          <div id="text" tabindex="0"></div>
        </div>
      </div>

      <div id="right-panel">
        <div id="explanation-panel">
          <div class="panel-title">Пояснения</div>
          <div id="explanation-content">
            <div class="loading">Пояснения появятся при вводе кода...</div>
          </div>
        </div>
      </div>
    </div>

    <div id="my_dict" class="modal">
      <div class="modal-header">
        <button id="my_dict_ok">OK</button>
        <span class="close">✕</span>
      </div>
      <textarea id="dict_data" placeholder="Введите текст для тренировки..."></textarea>
      <div class="modal-options">
        <label>
          <input type="checkbox" id="enable_highlight">
          <span>Подсветка синтаксиса</span>
        </label>
        <label>
          <span>Язык:</span>
          <select id="code_language">
            <option value="">Нет</option>
            <option value="javascript">JavaScript</option>
            <option value="typescript">TypeScript</option>
            <option value="jsx">JSX</option>
            <option value="tsx">TSX</option>
            <option value="python">Python</option>
            <option value="java">Java</option>
            <option value="cpp">C++</option>
            <option value="csharp">C#</option>
            <option value="go">Go</option>
            <option value="rust">Rust</option>
            <option value="html">HTML</option>
            <option value="css">CSS</option>
          </select>
        </label>
        <label>
          <input type="checkbox" id="enable_explanations">
          <span>Включить пояснения</span>
        </label>
        <label>
          <span>Локальный файл:</span>
          <input type="file" id="explanations_file" accept=".json">
        </label>
        <label>
          <span>URL:</span>
          <input type="text" id="explanations_url" placeholder="https://example.com/explanations.json">
        </label>
        <div id="load-status"></div>
      </div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script>
    class KeyboardTrainer {
      constructor() {
        this.dict = [];
        this.currentLineIndex = 0;
        this.currentCharIndex = 0;
        this.highlightEnabled = false;
        this.codeLanguage = '';
        this.explanationsEnabled = false;
        this.explanationsData = {};
        this.currentExplanation = null;
        this.hasError = false;
        this.stats = {
          start: null,
          errors: 0,
          totalTime: 0,
          totalLength: 0,
          totalWords: 0,
          totalErrors: 0,
          linesCompleted: 0
        };

        this.elements = {
          text: document.getElementById('text'),
          error: document.getElementById('error'),
          speed: document.getElementById('speed'),
          dictLink: document.getElementById('dict-link'),
          refresh: document.getElementById('refresh'),
          myDict: document.getElementById('my_dict'),
          dictData: document.getElementById('dict_data'),
          myDictOk: document.getElementById('my_dict_ok'),
          enableHighlight: document.getElementById('enable_highlight'),
          codeLanguage: document.getElementById('code_language'),
          enableExplanations: document.getElementById('enable_explanations'),
          explanationsUrl: document.getElementById('explanations_url'),
          explanations_file: document.getElementById('explanations_file'),
          loadStatus: document.getElementById('load-status'),
          explanationContent: document.getElementById('explanation-content')
        };

        this.init();
      }

      init() {
        this.elements.dictLink.addEventListener('click', () => this.showModal());
        this.elements.myDictOk.addEventListener('click', () => this.loadCustomText());
        this.elements.refresh.addEventListener('click', () => this.refresh());

        document.querySelectorAll('.close').forEach(el => {
          el.addEventListener('click', () => this.hideModal());
        });

        this.elements.text.addEventListener('keydown', (e) => this.handleKeyPress(e));
        this.elements.text.addEventListener('click', () => this.elements.text.focus());

        this.elements.enableHighlight.addEventListener('change', (e) => {
          this.elements.codeLanguage.disabled = !e.target.checked;
        });

        this.loadDefaultText();
        this.elements.text.focus();
      }

      showModal() {
        this.elements.myDict.classList.add('show');
        this.elements.dictData.focus();
      }

      hideModal() {
        this.elements.myDict.classList.remove('show');
        this.elements.text.focus();
        this.elements.explanations_file.value = '';
      }

      loadDefaultText() {
        const defaultText = `Добро пожаловать в клавиатурный тренажер!
Введите свой текст для практики.
Welcome to keyboard trainer!
Enter your text for practice.`;
        this.dict = this.parseText(defaultText);
        this.highlightEnabled = false;
        this.codeLanguage = '';
        this.explanationsEnabled = false;
        this.generateLines();
        this.clearStats();
      }

      parseText(text) {
        return text
          .replace(/\r/g, '\n')
          .replace(/\n{2,}/g, '\n')
          .replace(/\t/g, ' ')
          .replace(/ {2,}/g, ' ')
          .trim()
          .split('\n')
          .map(line => line.trim())
          .filter(line => line.length > 0);
      }

      async loadCustomText() {
        const text = this.elements.dictData.value.trim();
        if (!text) return;

        this.highlightEnabled = this.elements.enableHighlight.checked;
        this.codeLanguage = this.elements.codeLanguage.value;
        this.explanationsEnabled = this.elements.enableExplanations.checked;

        if (this.explanationsEnabled) {
          const fileInput = this.elements.explanations_file;
          const url = this.elements.explanationsUrl.value.trim();

          if (fileInput.files && fileInput.files[0]) {
            await this.loadExplanationsFromFile(fileInput.files[0]);
          } else if (url) {
            await this.loadExplanationsFile(url);
          } else {
            this.showStatus('Укажите файл или URL', 'error');
            return;
          }
        }

        this.dict = this.parseText(text);
        this.currentLineIndex = 0;
        this.generateLines();
        this.clearStats();
        this.hideModal();
        this.updateExplanation();
      }

      async loadExplanationsFromFile(file) {
        this.showStatus('Чтение файла...', 'loading');
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = (e) => {
            try {
              const data = JSON.parse(e.target.result);
              if (typeof data !== 'object' || data === null) throw new Error('Неверный JSON');
              this.explanationsData = data;
              this.showStatus(`Загружено ${Object.keys(data).length} пояснений`, 'success');
              setTimeout(() => this.elements.loadStatus.innerHTML = '', 3000);
              resolve();
            } catch (err) {
              this.showStatus(`Ошибка: ${err.message}`, 'error');
              this.explanationsEnabled = false;
              reject(err);
            }
          };
          reader.onerror = () => {
            this.showStatus('Ошибка чтения', 'error');
            reject();
          };
          reader.readAsText(file);
        });
      }

      async loadExplanationsFile(url) {
        this.showStatus('Загрузка...', 'loading');
        try {
          const res = await fetch(url);
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          this.explanationsData = await res.json();
          this.showStatus(`Загружено ${Object.keys(this.explanationsData).length} пояснений`, 'success');
          setTimeout(() => this.elements.loadStatus.innerHTML = '', 3000);
        } catch (e) {
          this.showStatus(`Ошибка: ${e.message}`, 'error');
          this.explanationsEnabled = false;
        }
      }

      showStatus(msg, type) {
        const cls = type === 'error' ? 'error-message' : 'status-message';
        this.elements.loadStatus.innerHTML = `<div class="${cls}">${msg}</div>`;
      }

      clearStats() {
        this.stats = { start: null, errors: 0, totalTime: 0, totalLength: 0, totalWords: 0, totalErrors: 0, linesCompleted: 0 };
        this.currentCharIndex = 0;
        this.hasError = false;
        this.updateDisplay();
      }

      refresh() {
        this.currentLineIndex = 0;
        this.generateLines();
        this.clearStats();
        this.updateExplanation();
      }

      generateLines() {
        this.elements.text.innerHTML = '';
        const numLines = 8;
        for (let i = 0; i < numLines; i++) {
          if (this.currentLineIndex >= this.dict.length) this.currentLineIndex = 0;
          const text = this.dict[this.currentLineIndex++];
          const line = this.createLine(text);
          this.elements.text.appendChild(line);
        }
        this.updateCursor();
      }

      createLine(text) {
        const div = document.createElement('div');
        div.className = 'line';
        
        if (this.highlightEnabled && this.codeLanguage) {
          // Подсветка синтаксиса
          try {
            const highlighted = hljs.highlight(text, { 
              language: this.codeLanguage, 
              ignoreIllegals: true 
            }).value;
            
            // Создаем временный элемент для парсинга HTML
            const temp = document.createElement('div');
            temp.innerHTML = highlighted;
            
            // Рекурсивно оборачиваем символы, сохраняя классы подсветки
            this.wrapCharsInElement(temp, div, text);
          } catch (e) {
            // Если ошибка подсветки, используем простой текст
            for (let i = 0; i < text.length; i++) {
              const span = document.createElement('span');
              span.className = 'char';
              span.textContent = text[i];
              div.appendChild(span);
            }
          }
        } else {
          // Простой текст без подсветки
          for (let i = 0; i < text.length; i++) {
            const span = document.createElement('span');
            span.className = 'char';
            span.textContent = text[i];
            div.appendChild(span);
          }
        }
        
        return div;
      }

      wrapCharsInElement(source, target, originalText) {
        let charIndex = 0;
        
        const processNode = (node, parentClasses = '') => {
          if (node.nodeType === Node.TEXT_NODE) {
            const text = node.textContent;
            for (let i = 0; i < text.length; i++) {
              if (charIndex < originalText.length) {
                const span = document.createElement('span');
                span.className = 'char' + (parentClasses ? ' ' + parentClasses : '');
                span.textContent = originalText[charIndex];
                target.appendChild(span);
                charIndex++;
              }
            }
          } else if (node.nodeType === Node.ELEMENT_NODE) {
            const classes = parentClasses + (node.className ? ' ' + node.className : '');
            Array.from(node.childNodes).forEach(child => {
              processNode(child, classes);
            });
          }
        };
        
        Array.from(source.childNodes).forEach(node => processNode(node));
      }

      handleKeyPress(e) {
        // Игнорируем модификаторы и функциональные клавиши
        if (e.ctrlKey || e.altKey || e.metaKey) {
          // Разрешаем Ctrl+R для обновления страницы
          if (e.ctrlKey && e.key === 'r') return;
          // Разрешаем Ctrl+A для выделения
          if (e.ctrlKey && e.key === 'a') return;
          e.preventDefault();
          return;
        }
        
        const line = this.elements.text.children[0];
        if (!line) return;

        const chars = line.querySelectorAll('.char');
        if (this.currentCharIndex >= chars.length) return;

        const expectedChar = chars[this.currentCharIndex].textContent;

        // ESC - сброс
        if (e.key === 'Escape') {
          e.preventDefault();
          this.refresh();
          return;
        }

        // Backspace - возврат назад
        if (e.key === 'Backspace') {
          e.preventDefault();
          if (this.currentCharIndex > 0) {
            this.currentCharIndex--;
            chars[this.currentCharIndex].classList.remove('checked');
            this.hasError = false;
            this.updateCursor();
          }
          return;
        }

        // Игнорируем служебные клавиши
        if (e.key.length !== 1) {
          e.preventDefault();
          return;
        }

        e.preventDefault();

        // Старт таймера
        if (!this.stats.start) {
          this.stats.start = Date.now();
        }

        // Проверка правильности ввода
        if (e.key === expectedChar) {
          if (!this.hasError) {
            // Правильный ввод
            chars[this.currentCharIndex].classList.add('checked');
            this.currentCharIndex++;

            if (this.currentCharIndex >= chars.length) {
              // Строка завершена
              this.completeLine(Array.from(chars).map(c => c.textContent).join(''));
            } else {
              this.updateCursor();
            }
          } else {
            // Была ошибка, но теперь правильный символ - сбрасываем ошибку
            this.hasError = false;
            this.updateCursor();
          }
        } else {
          // Неправильный ввод
          this.hasError = true;
          this.stats.errors++;
          this.updateCursor();
        }

        this.updateExplanation();
      }

      updateCursor() {
        const line = this.elements.text.children[0];
        if (!line) return;

        const chars = line.querySelectorAll('.char');
        chars.forEach((char, index) => {
          char.classList.remove('current', 'error');
          if (index === this.currentCharIndex) {
            char.classList.add('current');
            if (this.hasError) {
              char.classList.add('error');
            }
          }
        });
      }

      completeLine(text) {
        const time = (Date.now() - this.stats.start) / 1000;
        const len = text.length;
        const words = text.split(' ').filter(w => w).length;
        const speed = len / time * 60;
        
        if (speed < 3000) {
          this.stats.totalTime += time;
          this.stats.totalLength += len;
          this.stats.totalWords += words;
          this.stats.totalErrors += this.stats.errors;
          this.stats.linesCompleted++;
        }
        
        this.updateDisplay();
        this.shiftLines();
        this.currentCharIndex = 0;
        this.hasError = false;
        this.stats.start = null;
        this.stats.errors = 0;
        this.updateCursor();
        this.updateExplanation();
      }

      shiftLines() {
        const firstLine = this.elements.text.children[0];
        if (firstLine) {
          this.elements.text.removeChild(firstLine);
        }

        if (this.currentLineIndex >= this.dict.length) {
          this.currentLineIndex = 0;
        }
        
        const text = this.dict[this.currentLineIndex++];
        const newLine = this.createLine(text);
        this.elements.text.appendChild(newLine);
      }

      updateDisplay() {
        if (!this.stats.totalLength) {
          this.elements.speed.textContent = '--';
          this.elements.error.textContent = '--';
          return;
        }
        
        const cps = this.stats.totalLength / this.stats.totalTime * 60;
        const wpm = this.stats.totalWords / this.stats.totalTime * 60;
        const err = (this.stats.totalErrors / this.stats.totalLength) * 100;
        
        this.elements.speed.textContent = `${Math.round(cps)} (${Math.round(cps / 5)}/${Math.round(wpm)})`;
        this.elements.error.textContent = `${err.toFixed(2)}%`;
      }

      updateExplanation() {
        const line = this.elements.text.children[0];
        if (!line) return;

        const lineText = line.textContent.trim();
        if (!lineText || this.currentExplanation === lineText) return;
        this.currentExplanation = lineText;

        if (!this.explanationsEnabled || !Object.keys(this.explanationsData).length) {
          this.elements.explanationContent.innerHTML = '<div class="loading">Пояснения отключены или не загружены</div>';
          return;
        }

        const words = this.extractWords(lineText);
        const found = this.findExplanations(words);
        
        if (!found.length) {
          this.elements.explanationContent.innerHTML = '<div class="no-explanations">Пояснений нет</div>';
          return;
        }

        this.elements.explanationContent.innerHTML = found.map(f =>
          `<div class="word-item"><div class="word-title">${this.escapeHtml(f.word)}</div><div class="word-description">${this.escapeHtml(f.explanation)}</div></div>`
        ).join('');
      }

      extractWords(line) {
        const m = line.match(/[a-zA-Z_][a-zA-Z0-9_]*|[<>{}()\[\]:;,.'"`]/g) || [];
        return [...new Set(m)];
      }

      findExplanations(words) {
        return words.map(w => this.explanationsData[w] ? { word: w, explanation: this.explanationsData[w] } : null).filter(Boolean);
      }

      escapeHtml(t) {
        const d = document.createElement('div');
        d.textContent = t;
        return d.innerHTML;
      }
    }

    new KeyboardTrainer();
  </script>
</body>

</html>